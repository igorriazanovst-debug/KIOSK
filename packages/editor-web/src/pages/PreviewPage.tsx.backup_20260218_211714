/**
 * PreviewPage.tsx
 * Страница предпросмотра проекта — полноэкранный режим без UI
 */

import React, { useEffect, useState } from 'react';
import { useSearchParams } from 'react-router-dom';
import { apiClient, Project as ServerProject } from '../services/api-client';
import './PreviewPage.css';

// Типы
interface Widget {
  id: string;
  type: string;
  x: number;
  y: number;
  width: number;
  height: number;
  rotation?: number;
  zIndex?: number;
  properties: Record<string, any>;
}

interface WidgetEvent {
  trigger: 'click' | 'hover';
  actions: WidgetAction[];
}

interface WidgetAction {
  type: 'url' | 'page' | 'popup' | 'widget_show' | 'widget_hide' | 'video_play' | 'video_stop';
  url?: string;
  openInNewTab?: boolean;
  pageId?: string;
  popupTitle?: string;
  popupContent?: string;
  popupWidth?: number;
  popupHeight?: number;
  targetWidgetId?: string;
}

interface LocalProject {
  id?: string;
  version: string;
  name: string;
  canvas: {
    width: number;
    height: number;
    backgroundColor?: string;
  };
  widgets: Widget[];
}

// ============================================
// CLIP-PATH ГЕНЕРАТОР (правильные полигоны)
// ============================================

function getClipPath(shape: string, w: number, h: number, cornerRadius: number = 0, usePx: boolean = false): string | undefined {
  const cx = w / 2;
  const cy = h / 2;
  const r = Math.min(w, h) / 2;

  const fmt = (px: number, py: number): string => {
    if (usePx) return `${px.toFixed(1)}px ${py.toFixed(1)}px`;
    return `${((px / w) * 100).toFixed(1)}% ${((py / h) * 100).toFixed(1)}%`;
  };

  const polygon = (sides: number, startAngle: number = -Math.PI / 2): string => {
    const points: string[] = [];
    for (let i = 0; i < sides; i++) {
      const angle = startAngle + (2 * Math.PI * i) / sides;
      points.push(fmt(cx + r * Math.cos(angle), cy + r * Math.sin(angle)));
    }
    return `polygon(${points.join(', ')})`;
  };

  switch (shape) {
    case 'circle':
      if (usePx) return `circle(${r.toFixed(1)}px at ${cx.toFixed(1)}px ${cy.toFixed(1)}px)`;
      return `circle(${r}px at ${cx}px ${cy}px)`;
    case 'ellipse':
      if (usePx) return `ellipse(${(w/2).toFixed(1)}px ${(h/2).toFixed(1)}px at ${cx.toFixed(1)}px ${cy.toFixed(1)}px)`;
      return `ellipse(50% 50% at 50% 50%)`;
    case 'triangle': {
      const angles = [-Math.PI / 2, Math.PI / 6, 5 * Math.PI / 6];
      const pts = angles.map(a => fmt(cx + r * Math.cos(a), cy + r * Math.sin(a)));
      return `polygon(${pts.join(', ')})`;
    }
    case 'diamond':
      return `polygon(${fmt(cx, 0)}, ${fmt(w, cy)}, ${fmt(cx, h)}, ${fmt(0, cy)})`;
    case 'pentagon':
      return polygon(5);
    case 'hexagon':
      return polygon(6);
    case 'octagon':
      return polygon(8);
    case 'star': {
      const pts: string[] = [];
      for (let i = 0; i < 10; i++) {
        const angle = (i * Math.PI / 5) - Math.PI / 2;
        const sr = i % 2 === 0 ? r : r * 0.5;
        pts.push(fmt(cx + sr * Math.cos(angle), cy + sr * Math.sin(angle)));
      }
      return `polygon(${pts.join(', ')})`;
    }
    case 'rounded-rectangle':
    case 'rectangle':
    default:
      return undefined;
  }
}

// ============================================
// MENU WIDGET КОМПОНЕНТ
// ============================================

interface MenuItemType {
  id: string;
  label: string;
  actions?: any[];
  children?: MenuItemType[];
}

interface MenuWidgetProps {
  widgetId: string;
  commonStyle: React.CSSProperties;
  items: MenuItemType[];
  isHorizontal: boolean;
  backgroundColor: string;
  textColor: string;
  hoverColor: string;
  fontSize: number;
  fontFamily: string;
  itemPadding: number;
  itemHeight: number;
  submenuBackgroundColor: string;
  submenuTextColor: string;
  borderWidth: number;
  borderColor: string;
  executeActions: (actions: any[]) => void;
}

const MenuWidget: React.FC<MenuWidgetProps> = ({
  widgetId, commonStyle, items, isHorizontal,
  backgroundColor, textColor, hoverColor,
  fontSize, fontFamily, itemPadding, itemHeight,
  submenuBackgroundColor, submenuTextColor,
  borderWidth, borderColor, executeActions,
}) => {
  const [hoveredItem, setHoveredItem] = useState<string | null>(null);
  const [expandedItem, setExpandedItem] = useState<string | null>(null);

  const containerStyle: React.CSSProperties = {
    ...commonStyle,
    backgroundColor,
    display: 'flex',
    flexDirection: isHorizontal ? 'row' : 'column',
    border: borderWidth > 0 ? `${borderWidth}px solid ${borderColor}` : 'none',
    overflow: 'visible',
    position: 'absolute',
  };

  const itemStyle = (itemId: string): React.CSSProperties => ({
    display: 'flex',
    alignItems: 'center',
    padding: `0 ${itemPadding}px`,
    height: `${itemHeight}px`,
    minWidth: isHorizontal ? 'auto' : '100%',
    color: hoveredItem === itemId ? submenuTextColor : textColor,
    backgroundColor: hoveredItem === itemId ? hoverColor : backgroundColor,
    fontSize: `${fontSize}px`,
    fontFamily,
    cursor: 'pointer',
    userSelect: 'none' as const,
    whiteSpace: 'nowrap' as const,
    transition: 'background-color 0.15s',
    position: 'relative' as const,
    boxSizing: 'border-box' as const,
  });

  const submenuStyle = (parentId: string): React.CSSProperties => ({
    display: expandedItem === parentId ? 'flex' : 'none',
    flexDirection: 'column',
    position: 'absolute',
    top: isHorizontal ? `${itemHeight}px` : '0',
    left: isHorizontal ? '0' : '100%',
    backgroundColor: submenuBackgroundColor,
    zIndex: 9999,
    minWidth: '150px',
    boxShadow: '2px 4px 12px rgba(0,0,0,0.4)',
  });

  return (
    <div data-widget-id={widgetId} style={containerStyle}>
      {items.map((item) => {
        const hasChildren = item.children && item.children.length > 0;
        return (
          <div
            key={item.id}
            style={{ position: 'relative' }}
            onMouseEnter={() => {
              setHoveredItem(item.id);
              if (hasChildren) setExpandedItem(item.id);
            }}
            onMouseLeave={() => {
              setHoveredItem(null);
              if (hasChildren) setExpandedItem(null);
            }}
          >
            <div
              style={itemStyle(item.id)}
              onClick={() => {
                if (item.actions && item.actions.length > 0) {
                  executeActions(item.actions);
                }
              }}
            >
              {item.label}
              {hasChildren && (
                <span style={{ marginLeft: '6px', fontSize: '10px', opacity: 0.7 }}>
                  {isHorizontal ? '▼' : '▶'}
                </span>
              )}
            </div>
            {hasChildren && (
              <div style={submenuStyle(item.id)}>
                {item.children!.map((child) => (
                  <div
                    key={child.id}
                    style={{
                      padding: `0 ${itemPadding}px`,
                      height: `${itemHeight}px`,
                      display: 'flex',
                      alignItems: 'center',
                      color: hoveredItem === child.id ? textColor : submenuTextColor,
                      backgroundColor: hoveredItem === child.id ? hoverColor : 'transparent',
                      fontSize: `${fontSize - 2}px`,
                      fontFamily,
                      cursor: 'pointer',
                      userSelect: 'none',
                      whiteSpace: 'nowrap',
                      transition: 'background-color 0.15s',
                    }}
                    onMouseEnter={() => setHoveredItem(child.id)}
                    onMouseLeave={() => setHoveredItem(null)}
                    onClick={() => {
                      if (child.actions && child.actions.length > 0) {
                        executeActions(child.actions);
                      }
                    }}
                  >
                    {child.label}
                  </div>
                ))}
              </div>
            )}
          </div>
        );
      })}
    </div>
  );
};

// ============================================
// ОСНОВНОЙ КОМПОНЕНТ
// ============================================

const PreviewPage: React.FC = () => {
  const [searchParams] = useSearchParams();
  const projectId = searchParams.get('projectId');

  const [project, setProject] = useState<LocalProject | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [popupVisible, setPopupVisible] = useState(false);
  const [popupData, setPopupData] = useState<any>(null);
  const [hiddenWidgets, setHiddenWidgets] = useState<Set<string>>(new Set());

  // Загрузка проекта
  useEffect(() => {
    if (!projectId) {
      setError('Project ID not provided');
      setLoading(false);
      return;
    }

    const loadProject = async () => {
      try {
        const serverProject = await apiClient.getProject(projectId);
        const localProject: LocalProject = {
          id: serverProject.id,
          version: '1.0',
          name: serverProject.name,
          canvas: {
            width: serverProject.canvasWidth,
            height: serverProject.canvasHeight,
            backgroundColor: serverProject.canvasBackground,
          },
          widgets: serverProject.projectData?.widgets || [],
        };
        setProject(localProject);
      } catch (err: any) {
        setError(err.message || 'Failed to load project');
      } finally {
        setLoading(false);
      }
    };

    loadProject();
  }, [projectId]);

  // Удаление preview-snapshot при закрытии окна
  useEffect(() => {
    if (!projectId) return;

    const deleteSnapshot = () => {
      const token = localStorage.getItem('kiosk_client_token') || sessionStorage.getItem('kiosk_client_token');
      if (!token || !projectId) return;

      const baseUrl = window.location.origin;
      const url = `${baseUrl}/api/projects/${projectId}`;

      // Способ 1: sendBeacon с Blob (надёжнее при закрытии вкладки)
      try {
        const blob = new Blob([JSON.stringify({ _method: 'DELETE' })], { type: 'application/json' });
        // sendBeacon не поддерживает DELETE, поэтому используем XMLHttpRequest sync
        const xhr = new XMLHttpRequest();
        xhr.open('DELETE', url, false); // synchronous!
        xhr.setRequestHeader('Authorization', `Bearer ${token}`);
        xhr.send();
      } catch (e) {
        // Способ 2: fetch с keepalive
        fetch(url, {
          method: 'DELETE',
          headers: { 'Authorization': `Bearer ${token}` },
          keepalive: true
        }).catch(() => {});
      }
    };

    window.addEventListener('beforeunload', deleteSnapshot);
    window.addEventListener('pagehide', deleteSnapshot);

    return () => {
      window.removeEventListener('beforeunload', deleteSnapshot);
      window.removeEventListener('pagehide', deleteSnapshot);
      deleteSnapshot();
    };
  }, [projectId]);


  // Закрытие по ESC
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        if (popupVisible) {
          setPopupVisible(false);
        } else {
          window.close();
        }
      }
    };
    document.documentElement.requestFullscreen?.().catch(() => {});
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [popupVisible]);

  // Обработка действий виджетов
  const executeActions = (actions: WidgetAction[]) => {
    actions.forEach((action) => {
      switch (action.type) {
        case 'url':
          if (action.url) {
            if (action.openInNewTab) {
              window.open(action.url, '_blank');
            } else {
              window.location.href = action.url;
            }
          }
          break;
        case 'popup':
          setPopupData({
            title: action.popupTitle || 'Информация',
            content: action.popupContent || '',
            width: action.popupWidth || 400,
            height: action.popupHeight || 300,
          });
          setPopupVisible(true);
          break;
        case 'widget_show':
          if (action.targetWidgetId) {
            setHiddenWidgets((prev) => {
              const newSet = new Set(prev);
              newSet.delete(action.targetWidgetId!);
              return newSet;
            });
          }
          break;
        case 'widget_hide':
          if (action.targetWidgetId) {
            setHiddenWidgets((prev) => new Set(prev).add(action.targetWidgetId!));
          }
          break;
        case 'video_play':
          if (action.targetWidgetId) {
            const el = document.querySelector(`[data-widget-id="${action.targetWidgetId}"] video`) as HTMLVideoElement;
            if (el) el.play();
          }
          break;
        case 'video_stop':
          if (action.targetWidgetId) {
            const el = document.querySelector(`[data-widget-id="${action.targetWidgetId}"] video`) as HTMLVideoElement;
            if (el) { el.pause(); el.currentTime = 0; }
          }
          break;
      }
    });
  };

  // Рендер виджетов
  const renderWidget = (widget: Widget) => {
    if (hiddenWidgets.has(widget.id)) return null;

    const events = (widget as any).events as WidgetEvent[] | undefined;
    const handleClick = () => {
      if (events) {
        events.filter((e) => e.trigger === 'click').forEach((event) => executeActions(event.actions));
      }
    };

    const commonStyle: React.CSSProperties = {
      position: 'absolute',
      left: widget.x,
      top: widget.y,
      width: widget.width,
      height: widget.height,
      transform: widget.rotation ? `rotate(${widget.rotation}deg)` : undefined,
      transformOrigin: 'top left',
      cursor: events && events.some((e) => e.trigger === 'click') ? 'pointer' : 'default',
      zIndex: widget.zIndex || 0,
    };

    // Shape
    if (widget.type === 'shape') {
      const {
        shapeType = 'rectangle', fillColor = '#4a90e2',
        strokeColor = '#000000', strokeWidth = 0,
        cornerRadius = 0, opacity = 1,
      } = widget.properties;

      const shapeClip = getClipPath(shapeType, widget.width, widget.height, cornerRadius);
      const needsClip = shapeClip !== undefined;
      const br = shapeType === 'circle' ? '50%' : (shapeType === 'rounded-rectangle' || shapeType === 'rectangle' ? `${cornerRadius}px` : undefined);

      if (needsClip && strokeWidth > 0) {
        const scaleX = (widget.width - strokeWidth * 4) / widget.width;
        const scaleY = (widget.height - strokeWidth * 4) / widget.height;
        return (
          <div key={widget.id} data-widget-id={widget.id} style={{
            ...commonStyle,
            opacity,
          }} onClick={handleClick}>
            {/* Слой рамки — полная фигура цветом рамки */}
            <div style={{
              position: 'absolute', top: 0, left: 0,
              width: '100%', height: '100%',
              backgroundColor: strokeColor,
              clipPath: shapeClip,
              WebkitClipPath: shapeClip,
            } as React.CSSProperties} />
            {/* Слой заливки — та же фигура, уменьшена через scale */}
            <div style={{
              position: 'absolute', top: 0, left: 0,
              width: '100%', height: '100%',
              backgroundColor: fillColor,
              clipPath: shapeClip,
              WebkitClipPath: shapeClip,
              transform: `scale(${scaleX}, ${scaleY})`,
            } as React.CSSProperties} />
          </div>
        );
      }

      if (needsClip) {
        return (
          <div key={widget.id} data-widget-id={widget.id} style={{
            ...commonStyle,
            backgroundColor: fillColor,
            clipPath: shapeClip,
            WebkitClipPath: shapeClip,
            opacity,
          } as React.CSSProperties} onClick={handleClick} />
        );
      }

      return (
        <div key={widget.id} data-widget-id={widget.id} style={{
          ...commonStyle,
          backgroundColor: fillColor,
          border: strokeWidth > 0 ? `${strokeWidth}px solid ${strokeColor}` : 'none',
          borderRadius: br,
          opacity,
        } as React.CSSProperties} onClick={handleClick} />
      );
    }

    // Text
    if (widget.type === 'text') {
      const {
        text = 'Text', fontSize = 24, color = '#000000',
        fontFamily = 'Arial', fontWeight = 'normal',
        textAlign = 'left', verticalAlign = 'top',
        backgroundColor = 'transparent',
      } = widget.properties;

      const hAlign = textAlign === 'center' ? 'center' : textAlign === 'right' ? 'flex-end' : 'flex-start';
      const vAlign = verticalAlign === 'middle' ? 'center' : verticalAlign === 'bottom' ? 'flex-end' : 'flex-start';
      return (
        <div key={widget.id} data-widget-id={widget.id} style={{
          ...commonStyle,
          backgroundColor,
          display: 'flex',
          flexDirection: 'column',
          alignItems: hAlign,
          justifyContent: vAlign,
          whiteSpace: 'pre-wrap', wordWrap: 'break-word',
          overflow: 'hidden',
        }} onClick={handleClick}>
          <span style={{ fontSize: `${fontSize}px`, color, fontFamily, fontWeight, textAlign: textAlign as any, width: '100%' }}>{text}</span>
        </div>
      );
    }

    // Image (с clipShape)
    if (widget.type === 'image') {
      const {
        src = '', objectFit = 'contain', opacity = 1,
        clipShape = 'rectangle', cornerRadius = 0,
        borderEnabled = false, borderWidth = 2, borderColor = '#000000',
      } = widget.properties;
      if (!src) return null;

      const hasClip = clipShape && clipShape !== 'rectangle';
      const clipPath = hasClip ? getClipPath(clipShape, widget.width, widget.height, cornerRadius) : undefined;
      const effectiveObjectFit = hasClip ? 'cover' : objectFit;
      const br = (clipShape === 'rounded-rectangle' && cornerRadius) ? `${cornerRadius}px` : undefined;

      // Рамка по форме clip-path (двухслойный подход)
      if (hasClip && borderEnabled && borderWidth > 0) {
        const scaleX = (widget.width - borderWidth * 4) / widget.width;
        const scaleY = (widget.height - borderWidth * 4) / widget.height;
        return (
          <div key={widget.id} data-widget-id={widget.id} style={{
            ...commonStyle,
            opacity,
          }} onClick={handleClick}>
            {/* Слой рамки */}
            <div style={{
              position: 'absolute', top: 0, left: 0,
              width: '100%', height: '100%',
              backgroundColor: borderColor,
              clipPath: clipPath,
              WebkitClipPath: clipPath,
            } as React.CSSProperties} />
            {/* Слой изображения — уменьшен через scale */}
            <div style={{
              position: 'absolute', top: 0, left: 0,
              width: '100%', height: '100%',
              overflow: 'hidden',
              clipPath: clipPath,
              WebkitClipPath: clipPath,
              transform: `scale(${scaleX}, ${scaleY})`,
            } as React.CSSProperties}>
              <img src={src} alt="" style={{
                width: '100%', height: '100%',
                objectFit: effectiveObjectFit as any,
              }} />
            </div>
          </div>
        );
      }

      // Обычный рендер (без рамки по форме или прямоугольная)
      return (
        <div key={widget.id} data-widget-id={widget.id} style={{
          ...commonStyle,
          opacity,
          borderRadius: br,
          overflow: 'hidden',
          clipPath: clipPath,
          WebkitClipPath: clipPath,
          border: (borderEnabled && borderWidth > 0 && !hasClip) ? `${borderWidth}px solid ${borderColor}` : undefined,
        } as React.CSSProperties} onClick={handleClick}>
          <img src={src} alt="" style={{
            width: '100%', height: '100%',
            objectFit: effectiveObjectFit as any,
          }} />
        </div>
      );
    }

    // Video
    if (widget.type === 'video') {
      const { src = '', autoplay = false, loop = false, muted = true, objectFit = 'contain' } = widget.properties;
      if (!src) return null;

      return (
        <div key={widget.id} data-widget-id={widget.id} style={commonStyle} onClick={handleClick}>
          <video src={src} autoPlay={autoplay} loop={loop} muted={muted} style={{
            width: '100%', height: '100%', objectFit: objectFit as any,
          }} />
        </div>
      );
    }

    // Button
    if (widget.type === 'button') {
      const {
        text = 'Button', backgroundColor = '#4a90e2', textColor = '#ffffff',
        fontSize = 16, fontFamily = 'Arial', fontWeight = 'normal',
        textAlign = 'center', borderRadius = 4,
        borderWidth = 0, borderColor = '#000000', borderStyle = 'solid',
        paddingX = 16, paddingY = 8,
        shadowEnabled = false, shadowColor = '#000000',
        shadowBlur = 10, shadowOffsetX = 0, shadowOffsetY = 4, shadowOpacity = 0.3,
      } = widget.properties;

      return (
        <div key={widget.id} data-widget-id={widget.id} style={{
          ...commonStyle,
          backgroundColor, color: textColor,
          fontSize: `${fontSize}px`, fontFamily, fontWeight,
          borderRadius: `${borderRadius}px`,
          border: borderWidth > 0 ? `${borderWidth}px ${borderStyle} ${borderColor}` : 'none',
          display: 'flex', alignItems: 'center', justifyContent: 'center',
          cursor: 'pointer', userSelect: 'none',
          boxShadow: shadowEnabled ? `${shadowOffsetX}px ${shadowOffsetY}px ${shadowBlur}px ${shadowColor}${Math.round(shadowOpacity * 255).toString(16).padStart(2, '0')}` : undefined,
        }} onClick={handleClick}>
          {text}
        </div>
      );
    }

    // Menu
    if (widget.type === 'menu') {
      const {
        items = [], orientation = 'horizontal',
        backgroundColor = '#2c3e50', textColor = '#ffffff',
        hoverColor = '#34495e', fontSize = 16, fontFamily = 'Arial',
        itemPadding = 16, itemHeight = 40,
        submenuBackgroundColor = '#34495e', submenuTextColor = '#ffffff',
        borderWidth = 0, borderColor = '#000000',
      } = widget.properties;

      return (
        <MenuWidget
          key={widget.id} widgetId={widget.id} commonStyle={commonStyle}
          items={items} isHorizontal={orientation === 'horizontal'}
          backgroundColor={backgroundColor} textColor={textColor}
          hoverColor={hoverColor} fontSize={fontSize} fontFamily={fontFamily}
          itemPadding={itemPadding} itemHeight={itemHeight}
          submenuBackgroundColor={submenuBackgroundColor}
          submenuTextColor={submenuTextColor}
          borderWidth={borderWidth} borderColor={borderColor}
          executeActions={executeActions}
        />
      );
    }

    return null;
  };

  // Loading
  if (loading) {
    return (
      <div className="preview-page preview-loading">
        <div className="loading-spinner"></div>
      </div>
    );
  }

  // Error
  if (error || !project) {
    return (
      <div className="preview-page preview-error">
        <p>{error || 'Проект не найден'}</p>
      </div>
    );
  }

  return (
    <div className="preview-page">
      {/* Canvas — без масштабирования, 1:1 */}
      <div
        className="preview-canvas"
        style={{
          width: project.canvas.width,
          height: project.canvas.height,
          backgroundColor: project.canvas.backgroundColor || '#ffffff',
          position: 'relative',
        }}
      >
        {project.widgets
          .slice()
          .sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0))
          .map((widget) => renderWidget(widget))}
      </div>

      {/* Popup */}
      {popupVisible && popupData && (
        <div className="preview-popup-overlay" onClick={() => setPopupVisible(false)}>
          <div
            className="preview-popup"
            style={{ width: popupData.width, maxHeight: popupData.height }}
            onClick={(e) => e.stopPropagation()}
          >
            <div className="preview-popup-header">
              <h3>{popupData.title}</h3>
              <button onClick={() => setPopupVisible(false)}>×</button>
            </div>
            <div className="preview-popup-content">{popupData.content}</div>
          </div>
        </div>
      )}
    </div>
  );
};

export default PreviewPage;
