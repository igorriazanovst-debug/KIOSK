import { Router } from 'express';
import multer from 'multer';
import { spawn } from 'child_process';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import crypto from 'crypto';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const router = Router();

// –ü—É—Ç–∏
const PLAYER_PATH = path.join(__dirname, '..', '..', '..', 'player');
const TEMP_DIR = path.join(__dirname, '..', '..', 'data', 'temp');
const OUTPUT_DIR = path.join(__dirname, '..', '..', 'data', 'builds');

// –•—Ä–∞–Ω–∏–ª–∏—â–µ —Å–±–æ—Ä–æ–∫ (–≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ –ª—É—á—à–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ë–î)
const builds = new Map();

// Multer –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∫–æ–Ω–æ–∫
const storage = multer.diskStorage({
  destination: async (req, file, cb) => {
    await fs.mkdir(TEMP_DIR, { recursive: true });
    cb(null, TEMP_DIR);
  },
  filename: (req, file, cb) => {
    cb(null, `icon-${Date.now()}-${file.originalname}`);
  }
});

const upload = multer({ 
  storage,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5 MB
  fileFilter: (req, file, cb) => {
    if (file.mimetype === 'image/x-icon' || file.originalname.endsWith('.ico')) {
      cb(null, true);
    } else {
      cb(new Error('Only .ico files are allowed'));
    }
  }
});

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–∞–ø–æ–∫
async function initFolders() {
  await fs.mkdir(TEMP_DIR, { recursive: true });
  await fs.mkdir(OUTPUT_DIR, { recursive: true });
}

initFolders();


// –ó–∞–º–µ–Ω—è–µ—Ç –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ /api/... URL –Ω–∞ –∞–±—Å–æ–ª—é—Ç–Ω—ã–µ –≤ –¥–∞–Ω–Ω—ã—Ö –ø—Ä–æ–µ–∫—Ç–∞
function resolveProjectUrls(projectData, baseUrl) {
  const json = JSON.stringify(projectData);
  const resolved = json.replace(/\/api\//g, `${baseUrl}/api/`);
  return JSON.parse(resolved);
}

// –£—Ç–∏–ª–∏—Ç–∞: –∑–∞–ø—É—Å–∫ –∫–æ–º–∞–Ω–¥—ã
function runCommand(command, args, cwd) {
  return new Promise((resolve, reject) => {
    const process = spawn(command, args, {
      cwd,
      shell: true,
      stdio: 'pipe'
    });

    let stdout = '';
    let stderr = '';

    process.stdout.on('data', (data) => {
      stdout += data.toString();
      console.log(data.toString());
    });

    process.stderr.on('data', (data) => {
      stderr += data.toString();
      console.error(data.toString());
    });

    process.on('close', (code) => {
      if (code === 0) {
        resolve({ stdout, stderr });
      } else {
        reject(new Error(`Command failed with code ${code}\n${stderr}`));
      }
    });

    process.on('error', (err) => {
      reject(err);
    });
  });
}

// –§—É–Ω–∫—Ü–∏—è —Å–±–æ—Ä–∫–∏ –¥–∏—Å—Ç—Ä–∏–±—É—Ç–∏–≤–∞
async function buildDistribution(buildId, projectData, appName, appId, iconPath, serverBaseUrl = 'http://localhost:3002') {
  const updateStatus = (status, progress, message) => {
    builds.set(buildId, {
      ...builds.get(buildId),
      status,
      progress,
      message,
      updated_at: new Date().toISOString()
    });
  };

  try {
    updateStatus('preparing', 10, '–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Ñ–∞–π–ª–æ–≤');

    // 1. –ö–æ–ø–∏—Ä—É–µ–º –ø—Ä–æ–µ–∫—Ç –≤ player/electron/project.json
    // –ó–∞–º–µ–Ω—è–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ URL –Ω–∞ –∞–±—Å–æ–ª—é—Ç–Ω—ã–µ —á—Ç–æ–±—ã Electron –º–æ–≥ –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–∞–π–ª—ã
    const resolvedProjectData = resolveProjectUrls(projectData, serverBaseUrl);
    const projectJsonPath = path.join(PLAYER_PATH, 'electron', 'project.json');
    await fs.writeFile(projectJsonPath, JSON.stringify(resolvedProjectData, null, 2));
    console.log(`‚úÖ –ü—Ä–æ–µ–∫—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω: ${projectJsonPath}`);

    // 2. –û–±–Ω–æ–≤–ª—è–µ–º package.json
    updateStatus('configuring', 20, '–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤');
    
    const packageJsonPath = path.join(PLAYER_PATH, 'package.json');
    const packageJson = JSON.parse(await fs.readFile(packageJsonPath, 'utf-8'));
    
    packageJson.build = packageJson.build || {};
    packageJson.build.appId = appId;
    packageJson.build.productName = appName;
    
    // 3. –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∏–∫–æ–Ω–∫–∏
    if (iconPath) {
      const iconDestPath = path.join(PLAYER_PATH, 'assets', 'icon.ico');
      await fs.mkdir(path.join(PLAYER_PATH, 'assets'), { recursive: true });
      await fs.copyFile(iconPath, iconDestPath);
      packageJson.build.win = packageJson.build.win || {};
      packageJson.build.win.icon = 'assets/icon.ico';
      console.log(`‚úÖ –ò–∫–æ–Ω–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: ${iconDestPath}`);
    }
    
    await fs.writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2));
    console.log(`‚úÖ package.json –æ–±–Ω–æ–≤–ª–µ–Ω`);

    // 4. –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
    updateStatus('installing', 30, '–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π');
    
    const nodeModulesPath = path.join(PLAYER_PATH, 'node_modules');
    try {
      await fs.access(nodeModulesPath);
      console.log('‚úÖ node_modules —Å—É—â–µ—Å—Ç–≤—É–µ—Ç');
    } catch {
      console.log('üì¶ –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π...');
      await runCommand('npm', ['install'], PLAYER_PATH);
      console.log('‚úÖ –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã');
    }

    // 5. –°–±–æ—Ä–∫–∞ React –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    updateStatus('building', 50, '–°–±–æ—Ä–∫–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è');
    console.log('üî® –°–±–æ—Ä–∫–∞ React –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è...');
    await runCommand('npm', ['run', 'build'], PLAYER_PATH);
    console.log('‚úÖ React –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —Å–æ–±—Ä–∞–Ω–æ');

    // 6. –°–±–æ—Ä–∫–∞ Electron –¥–∏—Å—Ç—Ä–∏–±—É—Ç–∏–≤–∞
    updateStatus('packaging', 70, '–°–æ–∑–¥–∞–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤—â–∏–∫–∞');
    console.log('üì¶ –°–æ–∑–¥–∞–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤—â–∏–∫–∞ Windows...');
    await runCommand('npm', ['run', 'electron:build:win'], PLAYER_PATH);
    console.log('‚úÖ –£—Å—Ç–∞–Ω–æ–≤—â–∏–∫ —Å–æ–∑–¥–∞–Ω');

    // 7. –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤—â–∏–∫–∞ –≤ output
    updateStatus('finalizing', 90, '–§–∏–Ω–∞–ª–∏–∑–∞—Ü–∏—è');
    
    const distElectronPath = path.join(PLAYER_PATH, 'dist-electron');
    const files = await fs.readdir(distElectronPath);
    const setupFile = files.find(f => f.endsWith('.exe') && f.includes('Setup'));
    
    if (!setupFile) {
      throw new Error('–£—Å—Ç–∞–Ω–æ–≤—â–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ dist-electron');
    }

    const sourcePath = path.join(distElectronPath, setupFile);
    const outputFileName = `${appName.replace(/[^a-zA-Z0-9]/g, '_')}_Setup_${Date.now()}.exe`;
    const outputPath = path.join(OUTPUT_DIR, outputFileName);
    
    await fs.copyFile(sourcePath, outputPath);
    console.log(`‚úÖ –£—Å—Ç–∞–Ω–æ–≤—â–∏–∫ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω: ${outputPath}`);

    // –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞
    const stats = await fs.stat(outputPath);
    const fileSizeMB = (stats.size / (1024 * 1024)).toFixed(2);

    // 8. –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ
    updateStatus('completed', 100, '–ì–æ—Ç–æ–≤–æ!');
    builds.set(buildId, {
      ...builds.get(buildId),
      status: 'completed',
      progress: 100,
      message: '–£—Å—Ç–∞–Ω–æ–≤—â–∏–∫ –≥–æ—Ç–æ–≤',
      download_url: `/api/builds/download/${outputFileName}`,
      file_name: outputFileName,
      file_size: `${fileSizeMB} MB`,
      completed_at: new Date().toISOString()
    });

  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ —Å–±–æ—Ä–∫–∏:', error);
    updateStatus('failed', 0, error.message);
    builds.set(buildId, {
      ...builds.get(buildId),
      error: error.message,
      failed_at: new Date().toISOString()
    });
  }
}

/**
 * POST /api/builds
 * –ó–∞–ø—É—Å—Ç–∏—Ç—å —Å–±–æ—Ä–∫—É –¥–∏—Å—Ç—Ä–∏–±—É—Ç–∏–≤–∞
 */
router.post('/', upload.single('icon'), async (req, res) => {
  try {
    const { project, appName = 'Kiosk App', appId = 'com.kiosk.app' } = req.body;
    
    if (!project) {
      return res.status(400).json({ 
        success: false, 
        error: 'Project data is required' 
      });
    }

    // –ü–∞—Ä—Å–∏–º –ø—Ä–æ–µ–∫—Ç
    let projectData;
    try {
      projectData = typeof project === 'string' ? JSON.parse(project) : project;
    } catch (e) {
      return res.status(400).json({ 
        success: false, 
        error: 'Invalid project JSON' 
      });
    }

    // –°–æ–∑–¥–∞–µ–º –∑–∞–¥–∞—á—É —Å–±–æ—Ä–∫–∏
    const buildId = crypto.randomUUID();
    
    builds.set(buildId, {
      id: buildId,
      status: 'queued',
      progress: 0,
      message: '–í –æ—á–µ—Ä–µ–¥–∏',
      app_name: appName,
      app_id: appId,
      created_at: new Date().toISOString()
    });

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º buildId —Å—Ä–∞–∑—É
    res.json({
      success: true,
      data: {
        build_id: buildId,
        message: '–°–±–æ—Ä–∫–∞ –∑–∞–ø—É—â–µ–Ω–∞',
        status_url: `/api/builds/${buildId}`
      }
    });

    // –ó–∞–ø—É—Å–∫–∞–µ–º —Å–±–æ—Ä–∫—É –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
    const serverBaseUrl = `${req.protocol}://${req.get('host')}`;
    buildDistribution(buildId, projectData, appName, appId, req.file?.path, serverBaseUrl).catch(err => {
      console.error(`Build ${buildId} failed:`, err);
    });

  } catch (error) {
    console.error('Build error:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

/**
 * GET /api/builds/:buildId
 * –ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å —Å–±–æ—Ä–∫–∏
 */
router.get('/:buildId', (req, res) => {
  const { buildId } = req.params;
  const build = builds.get(buildId);

  if (!build) {
    return res.status(404).json({ 
      success: false, 
      error: 'Build not found' 
    });
  }

  res.json({ 
    success: true, 
    data: build 
  });
});

/**
 * GET /api/builds
 * –°–ø–∏—Å–æ–∫ –≤—Å–µ—Ö —Å–±–æ—Ä–æ–∫
 */
router.get('/', (req, res) => {
  const buildsList = Array.from(builds.values()).sort((a, b) => 
    new Date(b.created_at) - new Date(a.created_at)
  );
  
  res.json({ 
    success: true, 
    data: buildsList 
  });
});

/**
 * GET /api/builds/download/:fileName
 * –°–∫–∞—á–∞—Ç—å —É—Å—Ç–∞–Ω–æ–≤—â–∏–∫
 */
router.get('/download/:fileName', async (req, res) => {
  const { fileName } = req.params;
  const filePath = path.join(OUTPUT_DIR, fileName);

  try {
    await fs.access(filePath);
    res.download(filePath, fileName);
  } catch {
    res.status(404).json({ 
      success: false, 
      error: 'File not found' 
    });
  }
});

/**
 * DELETE /api/builds/:buildId
 * –£–¥–∞–ª–∏—Ç—å —Å–±–æ—Ä–∫—É
 */
router.delete('/:buildId', async (req, res) => {
  const { buildId } = req.params;
  const build = builds.get(buildId);

  if (!build) {
    return res.status(404).json({ 
      success: false, 
      error: 'Build not found' 
    });
  }

  // –£–¥–∞–ª—è–µ–º —Ñ–∞–π–ª –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å
  if (build.file_name) {
    const filePath = path.join(OUTPUT_DIR, build.file_name);
    try {
      await fs.unlink(filePath);
    } catch (e) {
      console.error('Failed to delete file:', e);
    }
  }

  builds.delete(buildId);
  
  res.json({ 
    success: true, 
    message: 'Build deleted' 
  });
});

export default router;
